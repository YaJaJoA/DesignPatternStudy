# Bridge
## 개요
두 개체가 독립적으로 달라질 수 있도록 구현에서 추상화를 분리함.
<br>
<br>

## 동기
추상화가 여러 가능한 구현 중 하나를 가질 수 있는 경우, 일반전인 방식은 상속을 이용하는 것이다. 추상 클래스는 추상화에 대한 인터페이스를 정의하고, 콘크리트 서브클래스는 다양한 방식으로 구현한다. 그러나 이러한 방식은 충분히 유연하지 않다. 상속은 추상화 및 구현을 독립적으로 수정, 확장 및 재사용하기 어렵다.

Bridge 패턴은 이러한 문제점들을 추상화와 구현을 분리된 클래스 계층에서 진행함으로 해결해준다.
<br>
<br>

## 사용처
* 추상화와 구현의 영구적인 바인딩을 피하고 싶을 떄
* 추상화와 구현이 서브클래싱으로 확장 가능해야할 때
* 추상화 구현의 변경은 클라이언트에 영향을 미치지 않아야 할 때
* (C++)클라이언트에게서 추상화의 구현을 숨기고 싶을 때
* 클래스가 급증할 때
* 여러 객체 간에 구현을 공유하고 싶고(아마도 참조 계산 사용) 이 것을 클라이언트에게서 숨겨야 할 때
<br>
<br>

## 구성
* Abstraction
    * 추상화 인터페이스 정의
    * Implementor 유형의 개체에 대한 참조를 유지 관리함.
* RefinedAbstraction
    * Abstraction에 의해 정의된 인터페이스 확장.
* Implementor
    * 구현 클래스를 위한 인터페이스 정의. 이 인터페이스는 Abstration의 인터페이스와 정확히 일치할 필요 없음(두 인터페이스는 살짝 다름). Implementor의 인터페이스는 기초 동작만 제공하지만, Abstraction은 기초 동작에 기반한 상위 레벨의 동장을 정의함.
* ConcreteImplementor
    * Implementor 인터페이스를 구현하고, 구체적인 구현을 정의함.
<br>
<br>

## 장단점
1. 인터페이스와 구현의 분리. 구현이 인터페이스에 영구 할당되지 않음.
2. 확장성 향상. Abstraction과 Implementor의 계층을 개별적으로 확장할 수 있음.
3. 클라이언트에게서 구현 내용을 숨길 수 있음.
<br>
<br>

## 관련 패턴
* Abstract Factory
* Adapter