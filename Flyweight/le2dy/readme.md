# Flyweight
## 개요
많은 수의 세밀한 개체들을 효율적으로 공유할 수 있게 지원함.
<br>
<br>

## 동기
일부 어플리케이션은 설계 전반에 걸쳐 개채를 사용하면 이점을 얻을 수 있지만 naive 구현에는 비용이 많이 든다.

예를 들어 문서 편집기를 만들다고 할 때, 문자 하나 하나가 개체로 구현한다면 수백, 수천개의 문자 개체들이 생겨날 것이다. 그러면 엄청난 메모리 소모와 허용할 수 없느 런타임 오버헤드가 발생할 수 있다.
<br>
이 문제를 해결하기 위한 해결책이 바로 Flyweight 패턴이다.
Flyweight 패턴은 엄청난 비용을 들이지 않고 세밀하게 사용할 수 있도록 개체를 공유하는 방법을 설명한다.
<br>
<br>

## 사용처
Flyweight 패턴은 아래 조건에 모두 해당할 때만 사용해야 한다.
* 어플리케이션이 엄청나게 많은 야의 개체를 사용할 때
* 스토리지가 엄청난 양의 개체 때문에 높은 비용을 소모할 때
* 대부분의 객체 상태가 외부적으로 만들어질 수 있을 때
* 많은 개체 그룹이 외부 상태가 제거됬을 때 관련 공유 개체들이 교체되야 할 때
* 어플리케이션이 개체 ID에 의존하지 않을 때
<br>
<br>

## 구성
* Flyweight
    * 외부 상태에서 flyweight가 행동하고 전달받을 수 있는 인터페이스 정의
* ConcreteFlyweight
    * flyweight 인터페이스 구현, 고유 상태에 대한 저장소를 추가함. 공유할 수 있어야 함.
* UnsharedConcreteFlyweight
    * 모든 flyweight 서브클래스를 공유할 필요는 없음. 공유 가능하지만 강제할 필요는 없음.
* FlyweightFactory
    * flyweight 개체를 만들고 관리함.
    * flyweight가 올바르게 공유되는지 확인함.
* Client
    * flyweight에 대한 참조를 유지함.
    * flyweight의 외부 상태를 저장하고 연산함.
<br>
<br>

## 장단점
Flyweight는 런타임 비용을 발생시킬 수 있다. 내부 상태가 많으수록 더 높은 비용을 발생한다. 하지만 Flyweight를 더 많이 공유함으로써 공간의 증가를 상쇄시킬 수 있다.
스토리지 절약은 다음 요소들의 함수이다.
* 공유로 인해 발생하는 총 인스턴스 수 감소
* 객체당 고유 상태의 양
* 외부 상태의 계산 및 저장 여부
외부 상태를 계산하는 것이 저장하는 것보다 비용 소모가 적다.
<br>
<br>

## 관련 패턴
* Composite
* State
* Strategy